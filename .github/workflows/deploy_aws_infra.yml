name: Deploy AWS Infrastructure
env:
  JUMPCLOUD_API_KEY: ${{ secrets.JUMPCLOUD_API_KEY }}

on:
  workflow_call:
    inputs:
      region:
        type: string
        required: true
      tf_version:
        type: string
        required: true
    secrets:
      aws_role:
        required: true
      tf_api_token:
        required: true
      jumpcloud_api_key:
        required: true
permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout
  pull-requests: write # This is required to Write the PR Comment

jobs:
  gather_changes:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    outputs:
      directories: ${{ steps.directories.outputs.modules }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3.3.0
        with:
          fetch-depth: 0

      - name: Generate Matrix
        uses: theappnest/terraform-monorepo-action@master
        id: directories
          
  terraform_deploy:
    name: Deploy AWS infrastructure
    runs-on: ubuntu-latest
    needs: gather_changes
    strategy:
      fail-fast: false
      matrix: 
        dir:  ${{ fromJson(needs.gather_changes.outputs.directories) }}
    defaults:
      run:
        shell: bash
        working-directory: ${{ matrix.dir }}
    outputs:
      created_accounts: ${{ steps.get_accounts.outputs.result }}
    steps:

    - name: Checkout Repo
      uses: actions/checkout@v3.3.0

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ inputs.region }}
        role-to-assume: ${{ secrets.AWS_ROLE }}
        role-duration-seconds: 3600

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ inputs.tf_version }}
        terraform_wrapper: true
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      env:
        API_KEY: ${{ secrets.JUMPCLOUD_API_KEY }}

    - name: Terraform Init
      id: init
      run: terraform init -input=false
      continue-on-error: false

    - name: Terraform Validation
      id: validate
      run: terraform validate -no-color

    - name: Terraform Format
      id: fmt
      run: terraform fmt -recursive

    - name: Terraform Plan
      id: plan
      if: github.event_name == 'pull_request'
      run: terraform plan -no-color -input=false 
      continue-on-error: false
      
    - name: Post Terraform Plan to PR
      uses: actions/github-script@v6
      if: github.event_name == 'pull_request'
      env:
        PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
      with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Try to find the starting index of the desired sections.
            const planOutput = process.env.PLAN.indexOf('Terraform used the selected providers to generate the following execution');
            const noChanges = process.env.PLAN.indexOf('No changes. Your infrastructure matches the configuration.');

            let filteredPlan = "";

            // Check which section is present and capture the appropriate content.
            if (planOutput !== -1) {
              filteredPlan = process.env.PLAN.slice(planOutput);
            } else if (noChanges !== -1) {
              filteredPlan = 'No changes. Your infrastructure matches the configuration.';
            } else {
              filteredPlan = process.env.PLAN; // fallback to the original content if neither section is found.
            }
            
            // 1. Retrieve existing bot comments for the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('${{ github.workflow }} ${{ matrix.dir }}')
            })

            // 2. Prepare format of the comment
            const output = `#### ${{ github.workflow }} ${{ matrix.dir }}
            #### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            <details><summary>Validation Output</summary>

            \`\`\`\n
            ${{ steps.validate.outputs.stdout }}
            \`\`\`

            </details>

            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan Results</summary>

            \`\`\`\n
            ${filteredPlan}
            \`\`\`

            </details>

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ env.tf_actions_working_dir }}\`, Workflow: \`${{ github.workflow }}\`*`;

            // 3. If we have a comment, update it, otherwise create a new one
            if (botComment) {
              github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              })
            } else {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              })
            }
       
    - name: Scan with Checkov
      id: checkov
      uses: bridgecrewio/checkov-action@v12.1347.0
      if: github.event_name == 'pull_request'
      with:
        directory: ${{ matrix.dir }}
        framework: terraform 
        output_format: cli
        download_external_modules: true

    - name: Post Checkov Scan to PR
      uses: actions/github-script@v6
      if: github.event_name == 'pull_request'
      with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Helper function to extract summary and failed checks
            function extractSummaryAndFailures(results) {
              const lines = results.split('\n');
              const summaryLine = lines.find(line => line.startsWith("terraform scan results:"));
              const failedChecks = [];
              const regexFailed = /FAILED for resource:/;

              // Extract failed checks
              for (let i = 0; i < lines.length; i++) {
                if (regexFailed.test(lines[i])) {
                  let failedBlock = lines[i];
                  let j = i + 1;

                  // Add subsequent lines relevant to the failed block
                  while (j < lines.length && lines[j].startsWith("\t")) {
                    failedBlock += `\n${lines[j]}`;
                    j++;
                  }
                  failedChecks.push(failedBlock);
                }
              }

              // Build the output
              let output = `#### Checkov Scan Results Summary\n\n`;
              output += summaryLine ? `${summaryLine}\n\n` : "No summary available.\n\n";

              if (failedChecks.length > 0) {
                output += `### Failed Checks:\n\n`;
                failedChecks.forEach((block, index) => {
                  output += `${index + 1}. ${block}\n\n`;
                });
              } else {
                output += `No failed checks. Great job! üéâ\n`;
              }

              return output;
            }

            // 1. Retrieve existing bot comments for the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const botComment = comments.find(comment => {
              return comment.user.type === 'Bot' && comment.body.includes('Checkov Scan Results');
            });

            // 2. Process the CHECKOV_RESULTS environment variable
            const checkovResults = process.env.CHECKOV_RESULTS || '';
            const output = extractSummaryAndFailures(checkovResults);

            // 3. Update or create the comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: output
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: output
              });
            }
      
    - name: Terraform Apply
      id : apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: terraform apply -auto-approve -input=false
      env:
        API_KEY: ${{ secrets.JUMPCLOUD_API_KEY }}

    - name: Wait For Account Creation To Complete
      id: wait
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        sleep 10m

    - name: Capture Created AWS Accounts
      id: get_accounts
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        accounts=$(terraform output -json created_aws_accounts | jq -c 'select(. != null)')
        if [[ -z "$accounts" ]]; then
          echo "result=[]" >> $GITHUB_OUTPUT
        else
          echo "result=$accounts" >> $GITHUB_OUTPUT
        fi

  process_accounts:
    name: Process AWS Accounts
    runs-on: ubuntu-latest
    needs: terraform_deploy
    if: ${{ needs.terraform_deploy.outputs.created_accounts != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        account_id: ${{ fromJson(needs.terraform_deploy.outputs.created_accounts) }}
    steps:

      - name: Checkout Repo
        uses: actions/checkout@v3.3.0

      - name: Configure AWS credentials (Initial Role)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.region }}
          role-to-assume: ${{ secrets.AWS_ROLE }}
          role-duration-seconds: 3600

      - name: Assume Target Role in Account
        id: assume-role
        run: |
          TEMP_ROLE=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ matrix.account_id }}:role/OrganizationAccountAccessRole" \
            --role-session-name GitHubActionSession)

          ACCESS_KEY=$(echo $TEMP_ROLE | jq -r '.Credentials.AccessKeyId')
          SECRET_KEY=$(echo $TEMP_ROLE | jq -r '.Credentials.SecretAccessKey')
          SESSION_TOKEN=$(echo $TEMP_ROLE | jq -r '.Credentials.SessionToken')

          echo "AWS_ACCESS_KEY_ID=${ACCESS_KEY}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=${SESSION_TOKEN}" >> $GITHUB_ENV

      - name: Set up Python environment
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Delete Default VPC
        run: |
          python ./aws-org/utilities/delete_default_vpc.py

      - name: Set Default Metadata Service
        run: |
          echo -e "Region          \t Modified" ; \
          echo -e "--------------  \t ---------" ; \
          for region in $(
              aws ec2 describe-regions \
                  --region us-east-1 \
                  --query "Regions[*].[RegionName]" \
                  --output text
              ); 
              do (output=$(
                  aws ec2 modify-instance-metadata-defaults \
                      --region $region \
                      --http-tokens required \
                      --http-put-response-hop-limit 2 \
                      --output text)
                  echo -e "$region        \t $output"
              );
          done
